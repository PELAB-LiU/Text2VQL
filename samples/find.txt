Given this metamodel

abstract class Pseudostate extends Vertex {
}
abstract class Vertex {
	reference Transition[0..*] incomingTransitions;
	reference Transition[0..*] outgoingTransitions;
}
class Region {
	reference Vertex[0..*] vertices;
	attribute EString[0..1] name;
}
class Transition {
	reference Vertex[1..1] target;
	reference Vertex[0..1] source;
}
class Statechart extends CompositeElement {
}
class Entry extends Pseudostate {
}
class Synchronization extends Pseudostate {
}
class State extends RegularState, CompositeElement {
}
abstract class RegularState extends Vertex {
}
abstract class CompositeElement {
	reference Region[0..*] regions;
}
class Choice extends Pseudostate {
}
class Exit extends Pseudostate {
}
class FinalState extends RegularState {
}

and the following Viatra Query examples

Example 1:
Description: "Vertex that has an incoming transition from a different region and an outgoing transition to a Pseudostate"
Query:
pattern regionAndPseudostate(vertex: Vertex){
	Vertex.outgoingTransitions(vertex, transition1);
	find toPseudoState(transition1);
	Vertex.incomingTransitions(vertex, transition2);
	find differentRegion(transition2);
}
//Auxiliary pattern
pattern toPseudoState(transition: Transition){
	Transition.target(transition, state);
	Pseudostate(state);
}
//Auxiliary pattern
pattern differentRegion(transition: Transition){
	Region.vertices(region1, vertex1);
	Transition.source(transition, vertex1);
	Transition.target(transition, vertex2);
	Region.vertices(region2,vertex2);
}

Example 2:
Description: "Final state that has an incoming transition from a Pseudostate"
Query: 
pattern regionWithPseudoToRegular(vertex: FinalState){
	Vertex.incomingTransitions(vertex, transition);
	FinalState(vertex);
	find pseudoToRegular(transition);
}
//Auxiliary pattern
pattern pseudoToRegular(transition: Transition){
	Transition.source(transition, source);
	Pseudostate(source);
	Transition.target(transition, target);
	RegularState(target);
}

Based on the followign mentamodel, generate 5 Viatra Query sets where the 1st query is an arbitrary query, and the 2nd query uses to the 1st with 'find' keyword. 
Extend the 2nd querry with additional constraints.
Also generate query descriptions.

class Database extends ModelElement {
	attribute EString[0..1] name;
	attribute EString[0..1] url;
	reference Schema[0..*] ownedSchemas;
}
class Schema extends ModelElement {
	attribute EString[0..1] name;
	reference Table[0..*] ownedTables;
	reference Database[1..1] owner;
}
class Table extends ModelElement {
	attribute EString[0..1] name;
	reference Column[0..*] ownedColumns;
	reference ForeignKey[0..*] ownedForeignKeys;
	reference Schema[1..1] owner;
}
class ForeignKey extends ModelElement {
	attribute EString[0..1] name;
	reference Table[1..1] foreignTable;
	reference Table[1..1] sourceTable;
}
class Column extends ModelElement {
	attribute EString[0..1] name;
	attribute Type[0..1] type;
	attribute EBoolean[0..1] isPrimaryKey;
	attribute EBoolean[0..1] isUnique;
	reference Table[1..1] owner;
}
enum Type {
	NUMERIC;
	VARCHAR;
	DATE;
	TIME;
	FLOAT;
	CHAR;
}
abstract class ModelElement {
	attribute EString[0..1] comment;
}

Use find <ither query> patterns.