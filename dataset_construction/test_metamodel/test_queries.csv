id,train_benchmark,nl,construct_vql,header_vql,truth_vql,construct_epl,header_epl,truth_epl,construct_ocl,header_ocl,truth_ocl
0,trainbenchmark-tool-viatra-patterns/src/hu/bme/mit/trainbenchmark/benchmark/viatra/SwitchSet.vql,Active route with GO entry semaphore and misaligned switch position. Misaligned means switch position where the target Switch's current position is different from the SwitchPosition's position.,find,pattern goRouteMisalignedSwitch(route: Route){,"pattern goRouteMisalignedSwitch(route: Route){
 find goRoute(route);
 Route.follows(route, swP);
 find misalignedSwitchPosition(swP);
}

pattern goRoute(route: Route){
	Route.active(route,true);
	Route.entry(route, semaphore);
	Semaphore.signal(semaphore, Signal::GO);	
}

pattern misalignedSwitchPosition(swP : SwitchPosition){
	SwitchPosition.target(swP, sw);
	SwitchPosition.position(swP, swpPosition);
	Switch.currentPosition(sw, swCurrentPosition);
	swpPosition != swCurrentPosition;
}",,,,,,
1,trainbenchmark-tool-viatra-patterns/src/hu/bme/mit/trainbenchmark/benchmark/viatra/ConnectedSegments.vql,Six segments monitored by with the same sensor. Each segment is connected to the next one.,find,"pattern connectedSegments6(sensor : Sensor, segment1 : Segment, segment2 : Segment, segment3 : Segment, segment4 : Segment, segment5 : Segment, segment6 : Segment){","pattern connectedSegments6(sensor : Sensor, segment1 : Segment, segment2 : Segment, segment3 : Segment, segment4 : Segment, segment5 : Segment, segment6 : Segment){
    find connectedSegmentWithSameMonitor(segment1, segment2, sensor);
    find connectedSegmentWithSameMonitor(segment2, segment3, sensor);
    find connectedSegmentWithSameMonitor(segment3, segment4, sensor);
    find connectedSegmentWithSameMonitor(segment4, segment5, sensor);
    find connectedSegmentWithSameMonitor(segment5, segment6, sensor);

}
pattern connectedSegmentWithSameMonitor(segment1: Segment, segment2: Segment, sensor: Sensor){
    Segment.connectsTo(segment1,segment2);
    Segment.monitoredBy(segment1,sensor);
    Segment.monitoredBy(segment2,sensor);
}",,,"pattern ConnectedSegments
  sensor : Sensor

  in: Sensor.all.select(s|s.monitors.select(s:Segment|true).size() > 5),

  segment1 : Segment from: sensor.monitors,
  segment2 : Segment from: segment1.connectsTo.select(s|s.monitoredBy.includes(sensor)),
  segment3 : Segment from: segment2.connectsTo.select(s|s.monitoredBy.includes(sensor)),
  segment4 : Segment from: segment3.connectsTo.select(s|s.monitoredBy.includes(sensor)),
  segment5 : Segment from: segment4.connectsTo.select(s|s.monitoredBy.includes(sensor)),
  segment6 : Segment from: segment5.connectsTo.select(s|s.monitoredBy.includes(sensor)) {

  do {
    Sequence {
      sensor,
      segment1, segment2, segment3,
      segment4, segment5, segment6
    }.println('ConnectedSegments: ');
  }

}",,,"package railway
  context Sensor
  def connectedSegments: Bag(TrackElement) = Sensor.allInstance()-> collect(sensor|
    sensor.monitors -> select(oclIsTypeOf(Segment)) -> collect(segment1 |
      segment1.connectsTo->select(oclIsTypeOf(Segemnt))->collect(segment2 |
        segment2.monitoredBy->includes(sensor))->collect(segment2 |
        segemnt2.connectsTo->select(oclIsTypeOf(Segemnt))->select(segment3 |
          segment3.monitoredBy->includes(sensor))->collect(segment3 |
          segment3.connectsTo->select(oclIsTypeOf(Segemnt))->select(segment4 |
            segment4.monitoredby->includes(sensor))->collect(segment4 |
            segment4.connectsTo->select(oclIsTypeOf(Segemnt))->select(segment5 |
              segment5.monitoredBy->includes(sensor))->collect(segment5 |
              segment5.connectsTo->select(oclIsTypeOf(Segemnt))->select(segment6 |
                segment6.monitoredBy->includes(sensor))))))))
endpackage"
2,,Semaphores with STOP or GO signals.,or,pattern stopOrGo(semaphore: Semaphore){,"pattern stopOrGo(semaphore: Semaphore){
    Semaphore.signal(semaphore, Signal::GO);
} or {
    Semaphore.signal(semaphore, Signal::STOP);
}",,,,,,
3,,TrackElements that are either connected or monitored by the same sensor.,or,"pattern relatedTrackElements(track1: TrackElement, track2: TrackElement){","pattern relatedTrackElements(track1: TrackElement, track2: TrackElement){
    TrackElement.monitoredBy(track1, sensor);
    TrackElement.monitoredBy(track2, sensor);
} or {
    TrackElement.connectsTo(track1,track2);
}",,,,,,
4,trainbenchmark-tool-viatra-patterns/src/hu/bme/mit/trainbenchmark/benchmark/viatra/SwitchMonitored.vql,Switches not monitored by a sensor.,neg,pattern switchNotMonitored(sw : Switch){,"pattern switchNotMonitored(sw : Switch){
    neg find hasSensor(sw);
}
//auxiliary pattern
pattern hasSensor(sw : Switch){
    TrackElement.monitoredBy(sw, _);
}",,,"pattern SwitchMonitored
  sw : Switch from: Switch.all.select(sw|sw.monitoredBy.size = 0) {

  do {
    sw.println('SwitchMonitored: ');
  }
}",,,"package railway
  context Switch
  def notMonitored: Set(Switch) = 
    switch.allInstances()->select(sw|sw.monitoredBy->isEmpty())
endpackage"
5,trainbenchmark-tool-viatra-patterns/src/hu/bme/mit/trainbenchmark/benchmark/viatra/RouteSensor.vql,Retrieve sensors that monitor a switch. The switch position that target that switch is followed by a route. That sensor is not required by the route.,neg,"pattern notRequiredRouteSensor(route : Route, sensor : Sensor, swP : SwitchPosition, sw : Switch){","pattern notRequiredRouteSensor(route : Route, sensor : Sensor, swP : SwitchPosition, sw : Switch){
    Route.follows(route, swP);
    SwitchPosition.target(swP, sw);
    TrackElement.monitoredBy(sw, sensor);
    neg find required(sensor, route);
}
//auxiliary pattern
pattern required(sensor : Sensor, route : Route){
    Route.requires(route, sensor);
}",,,"pattern RouteSensor
  route: Route,
  swP: SwitchPosition from: route.follows,
  sw: Switch from: swP.target,
  sensor: Sensor from: sw.monitoredBy.select(s|route.gathers.excludes(s))
{
  do {
    Sequence {
      route, swP, sw, sensor
    }.println('RouteSensor: ');
  }
}",,,"package railway
  context Route
  def routeSensor: Bag(Sensor) = Route.allInstances()->collect(route|
    route.follows->collect(swP|swP.target->collect(
      sw | sw.monitoredBy->select(sensor|route.gathers->excludes(sensor))
    )))
endpackage"
6,,Total length of segments.,agg,pattern totalLength(length: java Integer){,"pattern totalLength(length: java Integer){
    length == sum find segmentLength(_,#);
}
pattern segmentLength(segment: Segment, length: java Integer){
    Segment.length(segment, length);
}",,,,,,
7,,Track elements monitored by at lest two sensors.,agg,pattern monitoredBy2Sensors(track: TrackElement){,"pattern monitoredBy2Sensors(track: TrackElement){
    cnt == count find trackMonitoredBy(track, _);
    check(cnt >= 2);
}
pattern trackMonitoredBy(track: TrackElement, sensor: Sensor){
    TrackElement.monitoredBy(track, sensor);
}",,,,,,
8,,RailwayElements that are either Switches or SwitchPositions.,type,pattern switchOrSwitchPositionRailwayElemements(raliway: RailwayElement){,"pattern switchOrSwitchPositionRailwayElemements(raliway: RailwayElement){
    Switch(raliway);
} or {
    SwitchPosition(raliway);
}",,,,,,
9,,Railway elements that are Switches.,type,pattern switchRailwayElements(railway: RailwayElement){,"pattern switchRailwayElements(railway: RailwayElement){
    Switch(railway);
}",,,,,,
10,,Active routes with entry GO semaphore.,normal,pattern goActiveRoute(route: Route){,"pattern goActiveRoute(route: Route){
    Route.active(route,true);
    Route.entry(route, semaphore);
    Semaphore.signal(semaphore, Signal::GO);    
}",,,,,,
11,trainbenchmark-tool-viatra-patterns/src/hu/bme/mit/trainbenchmark/benchmark/viatra/PosLength.vql,Retrieve all segments whose lengths are less or equal than zero.,normal,pattern posLength(segment : Segment){,"pattern posLength(segment : Segment){
    Segment.length(segment, length);
    check(length <= 0);
}",,,"pattern PosLength
  segment : Segment in: Segment.all.select(s|s.length <= 0) {

  do {
    segment.println('PosLength: ');
  }
}",,,"package railway
  context Segment
  def negLength: Set(Segemtn) = 
    Segment.allInstances()->select(segment | segment.length <= 0)
endpackage"
12,,SwitchPositions where the target Switch's current position is different from the SwitchPosition's position.,normal,pattern misalignedSwitchPosition(swP : SwitchPosition){,"pattern misalignedSwitchPosition(swP : SwitchPosition){
    SwitchPosition.target(swP, sw);
    SwitchPosition.position(swP, swpPosition);
    Switch.currentPosition(sw, swCurrentPosition);
    swpPosition != swCurrentPosition;
}",,,,,,
13,,"Regions where the sum of segments lengths is at least 50, or regions with at least 10 sensors.",mix,pattern bigRegion(region: Region){,"pattern bigRegion(region: Region){
    length == sum find trackLengthInRegion(region, _,#);
    check(length >= 50);
} or {
    cnt == count find sensorInRegion(region, _);
    check(cnt >= 10);
}
pattern trackLengthInRegion(region: Region, track: Segment, length: EInt){
    Region.elements(region,track);
    Segment.length(track,length);
}
pattern sensorInRegion(region:Region, sensor: Sensor){
    Region.sensors(region,sensor);
}",,,,,,
14,,Segments that are at least 7 units long or are switches.,mix,pattern sevenSegmentOrSwitch(track: TrackElement){,"pattern sevenSegmentOrSwitch(track: TrackElement){
    Switch(track);
} or {
    Segment.length(track, length);
    check(length >= 7);
}",,,,,,
15,,Active route whose entry is a GO semaphore but not monitored by any sensor.,mix,pattern dangerousRoute(route: Route){,"pattern dangerousRoute(route: Route){
        find activeRouteWithGO(route);
        neg find routeMonitroedBy(route,_);
}
pattern routeMonitroedBy(route: Route, sensor: Sensor){
    Route.requires(route, sensor);
}
pattern activeRouteWithGO(route: Route){
    Route.active(route, true);
    Route.entry(route, entry);
    Semaphore.signal(entry, ::GO);
}",,,,,,
16,https://github.com/ftsrg/trainbenchmark/blob/master/trainbenchmark-tool-viatra-patterns/src/hu/bme/mit/trainbenchmark/benchmark/viatra/SemaphoreNeighbor.vql,"Two different routes where the exit semaphore of a route is not the entry semaphore of the other. Each route requires a sensor, and the sensors monitor connected tracks.",neg,"pattern semaphoreNeighbor(semaphore: Semaphore, route1: Route, route2: Route, sensor1: Sensor, sensor2: Sensor, te1: TrackElement, te2: TrackElement){","pattern semaphoreNeighbor(semaphore: Semaphore, route1: Route, route2: Route, sensor1: Sensor, sensor2: Sensor, te1: TrackElement, te2: TrackElement){
       Route.exit(route1, semaphore);
	Route.requires(route1, sensor1);
	TrackElement.monitoredBy(te1, sensor1);
	TrackElement.connectsTo(te1, te2);
	TrackElement.monitoredBy(te2, sensor2);
	Route.requires(route2, sensor2);
	
	neg find entrySemaphore(route2, semaphore);

	route1 != route2;
}

pattern entrySemaphore(route: Route, semaphore: Semaphore)
{
	Route.entry(route, semaphore);
}",,,,,,"package railway
  context Sensor
  def semNeighbor: Bag(Route) = Route.allInstances()->collect(
    route1 | route1.exit-ycollect(semaphore | route1.gathers->collect(
      sensor1 | sensor1.monitors-ycollect(te1|te1.connectsTo->collect(
        te2 | te2.monitoredBy ->collect(sensor2|Route.allInstances()
          -> select(route2 | route2 | reoute2.gathers->includes(sensor2)
            and route2.entry->exludes(semaphore)
            and route1 <> route2)))))))
endpackage"
17,,,,,,,,"pattern SwitchSet
  route: Route,
  semaphore: Semaphore from: Sequence{route.entry}.select(e | e.isDefined() and e.signal = 'GO'),
  swP: SwitchPosition from: route.follows,
  sw: Switch from: swP.target.select(t | t.currentPosition <> swP.position)
{
  do {
    Sequence {
      route, semaphore, swP, sw
    }.println('SwitchSet: ');
  }
}",,,"package railway
  context Switch
  def switchSet: Bag(Switch) = Route.allInstances(->collect(
    route | reoute.enty->select(signal='GO')->collect(semaphore | route.follows->collect(
      swP|swP.target->select(currentPosition<>swP.position))))
endpackage"
