Given this metamodel 

class Pseudostate extends Vertex {
}
class Vertex {
	ref Transition[0, *] incomingTransitions;
	ref Transition[0, *] outgoingTransitions;
}
class Region {
	ref Vertex[0, *] vertices;
}
class Transition {
	ref Vertex[1, 1] target;
	ref Vertex[0, 1] source;
}
class Statechart extends CompositeElement {
}
class Entry extends Pseudostate {
}
class Synchronization extends Pseudostate {
}
class State extends RegularState, CompositeElement {
}
class RegularState extends Vertex {
}
class CompositeElement {
	ref Region[0, *] regions;
}
class FinalState extends RegularState {
}

and the following Viatra Query examples

Example 1:
Description: "Region with at least 4 vertices."
Query:
pattern regionWith4OrMorevertices(region: Region) {
    cnt == count find verticesInRegion(region, _);
    check(cnt>=4);
}

//auxiliary pattern
pattern verticesInRegion(region: Region, vertex: Vertex){
	Region.vertices(region, vertex);
}

Example 2:
Description: "Verte with at most 3 outgoing transition."
Query:
pattern max3outgoing(vertex: Vertex) {
    cnt == count find outgoingHelper(region, _);
    check(cnt<=3);
}

//auxiliary pattern
pattern outgoingHelper(vertex: Vertex, transition: Transition){
	Vertex.outgoingTransitions(vertex, transition);
}

Example 3:
Description: "Number of States."
Query:
pattern countStates(cnt: java Integer) {
    cnt == count find stateHelper(_);
}

//auxiliary pattern
pattern stateHelper(state: State){
	State(state);
}

Example 4:
Description: "Vertex with the least incoming transitions."
Query:
pattern vertexLeastIncoming(vertex: Vertex, minlength: java Integer) {
    minlength == min find countIncomingTransitions(_, #);
    find countIncomingTransitions(vertex, current);
	current == minlength;
}	

//auxiliary pattern
pattern countIncomingTransitions(vertex : Vertex, cnt: java Integer) {
    cnt == count find incomingHelper(vertex, _);
}
//auxiliary pattern
pattern incomingHelper(vertex: Vertex, transition: Transition){
	Vertex.incomingTransitions(vertex, transition);
}

Example 5:
Description: "Tere are at least 5 Entries in the model."
Query:
pattern exist5entries() {
    cnt == count find entryHelper(_);
    check(cnt>=5);
}

//auxiliary pattern
pattern entryHelper(entry: Entry){
	Entry(entry);
}

Based on the followign mentamodel, generate 4 Viatra Queries containing aggregation and their descriptions .
Tips:
* Use helper patterns for count find.
* Use # for min, max, avg, or sum.

class Database extends ModelElement {
	attr EString[0, 1] name;
	attr EString[0, 1] url;
	ref Schema[0, *] ownedSchemas;
}
class Schema extends ModelElement {
	attr EString[0, 1] name;
	ref Table[0, *] ownedTables;
	ref Database[1, 1] owner;
}
class Table extends ModelElement {
	attr EString[0, 1] name;
	ref Column[0, *] ownedColumns;
	ref ForeignKey[0, *] ownedForeignKeys;
	ref Schema[1, 1] owner;
}
class ForeignKey extends ModelElement {
	attr EString[0, 1] name;
	ref Table[1, 1] foreignTable;
	ref Table[1, 1] sourceTable;
}
class Column extends ModelElement {
	attr EString[0, 1] name;
	attr Type[0, 1] type;
	attr EBoolean[0, 1] isPrimaryKey;
	attr EBoolean[0, 1] isUnique;
	ref Table[1, 1] owner;
}
enum Type {
	NUMERIC;
	VARCHAR;
	DATE;
	TIME;
	FLOAT;
	CHAR;
}
class ModelElement {
	attr EString[0, 1] comment;
}

