Given this metamodel 

abstract class Pseudostate extends Vertex {
}
abstract class Vertex {
	reference Transition[0..*] incomingTransitions;
	reference Transition[0..*] outgoingTransitions;
}
class Region {
	reference Vertex[0..*] vertices;
	attribute EString[0..1] name;
}
class Transition {
	reference Vertex[1..1] target;
	reference Vertex[0..1] source;
}
class Statechart extends CompositeElement {
}
class Entry extends Pseudostate {
}
class Synchronization extends Pseudostate {
}
class State extends RegularState, CompositeElement {
}
abstract class RegularState extends Vertex {
}
abstract class CompositeElement {
	reference Region[0..*] regions;
}
class Choice extends Pseudostate {
}
class Exit extends Pseudostate {
}
class FinalState extends RegularState {
}

and the following Viatra Query examples

Example 1:
Description: "Transitions with their sources and targets"
Query:
pattern transition(transition : Transition, source : Vertex, vertex : Vertex) {
	Transition.source(transition, source);
	Transition.target(transition, vertex);
}

Example 2:
Description: "All entries with their regions"
Query:
pattern entryInRegion(region : Region, entry : Entry) {
	Region.vertices(region, entry);
}

Example 3:
Description: "Regions where their name contains "noraml" "
Query:
pattern normalRegion(region: Region){
	Region.name(region, name);
	check(name.contains("normal"));
}

Example 4:
Description: "Regions that have several vertexes"
Query:
pattern regionWithSeveralEntries(region : Region) {
	Region.vertices(region, vertex1);
	Region.vertices(region, vertex2);
	vertex1 != vertex2;
}

Example 5: 
Description. "Entries that have multiple outgoing transitions"
QUERY:
pattern entryWithMultipleOutgoingTransitions(entry : Entry) {
	Entry.outgoingTransitions(entry, transition1);
	Entry.outgoingTransitions(entry, transition2);
	transition1 != transition2;
}

Generate 10 Viatra Queries of different complexity and their descriptions based on the following metamodel

class Database extends ModelElement {
	attribute EString[0..1] name;
	attribute EString[0..1] url;
	reference Schema[0..*] ownedSchemas;
}
class Schema extends ModelElement {
	attribute EString[0..1] name;
	reference Table[0..*] ownedTables;
	reference Database[1..1] owner;
}
class Table extends ModelElement {
	attribute EString[0..1] name;
	reference Column[0..*] ownedColumns;
	reference ForeignKey[0..*] ownedForeignKeys;
	reference Schema[1..1] owner;
}
class ForeignKey extends ModelElement {
	attribute EString[0..1] name;
	reference Table[1..1] foreignTable;
	reference Table[1..1] sourceTable;
}
class Column extends ModelElement {
	attribute EString[0..1] name;
	attribute Type[0..1] type;
	attribute EBoolean[0..1] isPrimaryKey;
	attribute EBoolean[0..1] isUnique;
	reference Table[1..1] owner;
}
enum Type {
	NUMERIC;
	VARCHAR;
	DATE;
	TIME;
	FLOAT;
	CHAR;
}
abstract class ModelElement {
	attribute EString[0..1] comment;
}