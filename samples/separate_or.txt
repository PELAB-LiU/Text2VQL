Given this metamodel 

class Pseudostate extends Vertex {
}
class Vertex {
	ref Transition[0, *] incomingTransitions;
	ref Transition[0, *] outgoingTransitions;
}
class Region {
	ref Vertex[0, *] vertices;
}
class Transition {
	ref Vertex[1, 1] target;
	ref Vertex[0, 1] source;
}
class Statechart extends CompositeElement {
}
class Entry extends Pseudostate {
}
class Synchronization extends Pseudostate {
}
class State extends RegularState, CompositeElement {
}
class RegularState extends Vertex {
}
class CompositeElement {
	ref Region[0, *] regions;
...
}
class FinalState extends RegularState {
}

and the following Viatra Query examples

Example 1:
Description: "Veterx that are either entry or final state"
Query:
pattern entryOrSynchronizedState(s : Vertex ) {
    Entry(s);
} or {
    FinalState(s);
}

Example 2:
Description: Vertex that has incoming or outgoing transition.
pattern incomingOrOutgoing(vertex: Vertex){
	Vertex.incomingTransitions(vertex,_);
} or {
	Vertex.outgoingTransitions(vertex,_);
}

Example 3:
Description: State that are either entry state or has incoming transition.
pattern entryorIncoming(vertex: Vertex){
	Entry(vertex);
} or {
	Vertex.incomingTransitions(vertex,_);
}

Example 4:
Description: Transitions with the same source or same target.
Query:
pattern sameSourceOrTarget(transition1: Transition, transition2: Transition){
	Transition.source(transition1,source);
	Transition.source(transition2,source);
} or {
	Transition.target(transition1,target);
	Transition.target(transition2,target);
}

Generate 15 Viatra Queries of increasing complexity and ther descriptions that contain or statement based on the following metamodel

class Database extends ModelElement {
	attr EString[0, 1] name;
	attr EString[0, 1] url;
	ref Schema[0, *] ownedSchemas;
}
class Schema extends ModelElement {
	attr EString[0, 1] name;
	ref Table[0, *] ownedTables;
	ref Database[1, 1] owner;
}
class Table extends ModelElement {
	attr EString[0, 1] name;
	ref Column[0, *] ownedColumns;
	ref ForeignKey[0, *] ownedForeignKeys;
	ref Schema[1, 1] owner;
}
class ForeignKey extends ModelElement {
	attr EString[0, 1] name;
	ref Table[1, 1] foreignTable;
	ref Table[1, 1] sourceTable;
}
class Column extends ModelElement {
	attr EString[0, 1] name;
	attr Type[0, 1] type;
	attr EBoolean[0, 1] isPrimaryKey;
	attr EBoolean[0, 1] isUnique;
	ref Table[1, 1] owner;
}
enum Type {
	NUMERIC;
	VARCHAR;
	DATE;
	TIME;
	FLOAT;
	CHAR;
}
class ModelElement {
	attr EString[0, 1] comment;
}

Ensure that or statement can only be used between query bodies ( "} or {").