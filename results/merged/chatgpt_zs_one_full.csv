construct,train_benchmark,nl,header,truth,chatgpt_zs_0,chatgpt_zs_1,chatgpt_zs_2,chatgpt_zs_3,chatgpt_zs_4,has_correct,#truth,syntax_ok,match_ok
find,trainbenchmark-tool-viatra-patterns/src/hu/bme/mit/trainbenchmark/benchmark/viatra/SwitchSet.vql,Active route with GO entry semaphore and misaligned switch position. Misaligned means switch position where the target Switch's current position is different from the SwitchPosition's position.,pattern goRouteMisalignedSwitch(route: Route){,"pattern goRouteMisalignedSwitch(route: Route){
 find goRoute(route);
 Route.follows(route, swP);
 find misalignedSwitchPosition(swP);
}

pattern goRoute(route: Route){
	Route.active(route,true);
	Route.entry(route, semaphore);
	Semaphore.signal(semaphore, Signal::GO);	
}

pattern misalignedSwitchPosition(swP : SwitchPosition){
	SwitchPosition.target(swP, sw);
	SwitchPosition.position(swP, swpPosition);
	Switch.currentPosition(sw, swCurrentPosition);
	swpPosition != swCurrentPosition;
}","pattern goRouteMisalignedSwitch(route: Route) {
    Route.active(route, true);
    Route.entry(route, entrySemaphore);
    Semaphore.signal(entrySemaphore, Signal.GO);
    Route.follows(route, switchPos);
    SwitchPosition.position(switchPos, pos);
    SwitchPosition.target(switchPos, targetSwitch);
    Switch.currentPosition(targetSwitch, currentPos);
    Position.enumOrdinal(currentPos, currentPosOrd);
    Position.enumOrdinal(pos, posOrd);
    check(currentPosOrd != posOrd);
}","pattern goRouteMisalignedSwitch(route: Route) {
    Route.active(route, true);
    Route.entry(route, entrySemaphore);
    Semaphore.signal(entrySemaphore, Signal.GO);
    Route.follows(route, switchPosition);
    SwitchPosition.route(switchPosition, route);
    SwitchPosition.position(switchPosition, switchPositionPosition);
    SwitchPosition.target(switchPosition, targetSwitch);
    Switch.currentPosition(targetSwitch, currentPosition);
    SwitchPosition.position(switchPosition, switchPositionPosition);
    Position.values().indexOf(currentPosition) != Position.values().indexOf(switchPositionPosition);
}","pattern goRouteMisalignedSwitch(route: Route) {
	Route.active(route, true);
	Route.entry(route, entrySemaphore);
	Semaphore.signal(entrySemaphore, Signal::GO);
	Route.follows(route, switchPosition);
	SwitchPosition.position(switchPosition, switchPositionPosition);
	SwitchPosition.target(switchPosition, targetSwitch);
	Switch.currentPosition(targetSwitch, currentPosition);
	Position.valueOf(switchPositionPosition) != Position.valueOf(currentPosition);
}","pattern goRouteMisalignedSwitch(route: Route) {
	Route.active(route, true);
	Route.entry(route, entrySemaphore);
	Semaphore.signal(entrySemaphore, Signal.GO);
	Route.follows(route, switchPosition);
	SwitchPosition.position(switchPosition, switchPositionPosition);
	SwitchPosition.target(switchPosition, targetSwitch);
	Switch.currentPosition(targetSwitch, currentSwitchPosition);
	check(Position.DIVERGING == switchPositionPosition && switchPositionPosition != currentSwitchPosition);
}","pattern goRouteMisalignedSwitch(route: Route) {
    Route.active(route, true);
    Route.entry(route, entrySemaphore);
    Semaphore.signal(entrySemaphore, Signal.GO);
    Route.follows(route, switchPosition);
    SwitchPosition.route(switchPosition, route);
    SwitchPosition.position(switchPosition, position);
    Switch.target(switchPosition, targetSwitch);
    Switch.currentPosition(targetSwitch, currentPosition);
    Position.valueOf(currentPosition, currentSwitchPosition);
    Position.valueOf(position, switchPositionPosition);
    check(currentSwitchPosition != switchPositionPosition);
}",False,96,"[false, false, false, false, false]","[false, false, false, false, false]"
find,trainbenchmark-tool-viatra-patterns/src/hu/bme/mit/trainbenchmark/benchmark/viatra/ConnectedSegments.vql,Six segments monitored by with the same sensor. Each segment is connected to the next one.,"pattern connectedSegments6(sensor : Sensor, segment1 : Segment, segment2 : Segment, segment3 : Segment, segment4 : Segment, segment5 : Segment, segment6 : Segment){","pattern connectedSegments6(sensor : Sensor, segment1 : Segment, segment2 : Segment, segment3 : Segment, segment4 : Segment, segment5 : Segment, segment6 : Segment){
    find connectedSegmentWithSameMonitor(segment1, segment2, sensor);
    find connectedSegmentWithSameMonitor(segment2, segment3, sensor);
    find connectedSegmentWithSameMonitor(segment3, segment4, sensor);
    find connectedSegmentWithSameMonitor(segment4, segment5, sensor);
    find connectedSegmentWithSameMonitor(segment5, segment6, sensor);

}
pattern connectedSegmentWithSameMonitor(segment1: Segment, segment2: Segment, sensor: Sensor){
    Segment.connectsTo(segment1,segment2);
    Segment.monitoredBy(segment1,sensor);
    Segment.monitoredBy(segment2,sensor);
}","pattern connectedSegments6(sensor : Sensor, segment1 : Segment, segment2 : Segment, segment3 : Segment, segment4 : Segment, segment5 : Segment, segment6 : Segment) {
    Sensor.monitors(sensor, segment1);
    Sensor.monitors(sensor, segment2);
    Sensor.monitors(sensor, segment3);
    Sensor.monitors(sensor, segment4);
    Sensor.monitors(sensor, segment5);
    Sensor.monitors(sensor, segment6);

    Segment.connectsTo(segment1, segment2);
    Segment.connectsTo(segment2, segment3);
    Segment.connectsTo(segment3, segment4);
    Segment.connectsTo(segment4, segment5);
    Segment.connectsTo(segment5, segment6);
}","pattern connectedSegments6(sensor : Sensor, segment1 : Segment, segment2 : Segment, segment3 : Segment, segment4 : Segment, segment5 : Segment, segment6 : Segment){
	find commonSensor(sensor, segment1);
	find commonSensor(sensor, segment2);
	find commonSensor(sensor, segment3);
	find commonSensor(sensor, segment4);
	find commonSensor(sensor, segment5);
	find commonSensor(sensor, segment6);
	find nextSegment(segment1, segment2);
	find nextSegment(segment2, segment3);
	find nextSegment(segment3, segment4);
	find nextSegment(segment4, segment5);
	find nextSegment(segment5, segment6);
}

pattern commonSensor(sensor : Sensor, segment : Segment){
	Segment.monitoredBy(segment, sensor);
}

pattern nextSegment(segment1 : Segment, segment2 : Segment){
	Segment.connectsTo(segment1, segment2);
}","pattern connectedSegments6(sensor : Sensor, segment1 : Segment, segment2 : Segment, segment3 : Segment, segment4 : Segment, segment5 : Segment, segment6 : Segment){
	find commonSensor(sensor, segment1);
	find commonSensor(sensor, segment2);
	find commonSensor(sensor, segment3);
	find commonSensor(sensor, segment4);
	find commonSensor(sensor, segment5);
	find commonSensor(sensor, segment6);

	find nextSegment(segment1, segment2);
	find nextSegment(segment2, segment3);
	find nextSegment(segment3, segment4);
	find nextSegment(segment4, segment5);
	find nextSegment(segment5, segment6);
}

pattern commonSensor(sensor : Sensor, segment : Segment){
	Segment.monitoredBy(segment, sensor);
}

pattern nextSegment(segment1 : Segment, segment2 : Segment){
	Segment.connectsTo(segment1, segment2);
}","pattern connectedSegments6(sensor : Sensor, segment1 : Segment, segment2 : Segment, segment3 : Segment, segment4 : Segment, segment5 : Segment, segment6 : Segment) {
    Sensor.monitors(sensor, segment1);
    Sensor.monitors(sensor, segment2);
    Sensor.monitors(sensor, segment3);
    Sensor.monitors(sensor, segment4);
    Sensor.monitors(sensor, segment5);
    Sensor.monitors(sensor, segment6);
    
    Segment.connectsTo(segment1, segment2);
    Segment.connectsTo(segment2, segment3);
    Segment.connectsTo(segment3, segment4);
    Segment.connectsTo(segment4, segment5);
    Segment.connectsTo(segment5, segment6);
}","pattern connectedSegments6(sensor : Sensor, segment1 : Segment, segment2 : Segment, segment3 : Segment, segment4 : Segment, segment5 : Segment, segment6 : Segment) {
    Segment.monitoredBy(segment1, sensor);
    Segment.monitoredBy(segment2, sensor);
    Segment.monitoredBy(segment3, sensor);
    Segment.monitoredBy(segment4, sensor);
    Segment.monitoredBy(segment5, sensor);
    Segment.monitoredBy(segment6, sensor);
    
    Segment.connectsTo(segment1, segment2);
    Segment.connectsTo(segment2, segment3);
    Segment.connectsTo(segment3, segment4);
    Segment.connectsTo(segment4, segment5);
    Segment.connectsTo(segment5, segment6);
}",True,74883,"[true, true, true, true, true]","[true, true, true, true, true]"
or,,Semaphores with STOP or GO signals.,pattern stopOrGo(semaphore: Semaphore){,"pattern stopOrGo(semaphore: Semaphore){
    Semaphore.signal(semaphore, Signal::GO);
} or {
    Semaphore.signal(semaphore, Signal::STOP);
}","pattern stopOrGo(semaphore: Semaphore){
	Semaphore.signal(semaphore, signal);
	check(signal == Signal::STOP || signal == Signal::GO);
}","pattern stopOrGo(semaphore: Semaphore) {
	Semaphore.signal(semaphore, signal);
	check(signal == Signal::STOP || signal == Signal::GO);
}","pattern stopOrGo(semaphore: Semaphore){
	Semaphore.signal(semaphore, signal);
	check(signal == Signal::STOP || signal == Signal::GO);
}","pattern stopOrGo(semaphore: Semaphore) {
	Semaphore.signal(semaphore, signal);
	check(signal == Signal::STOP || signal == Signal::GO);
}","pattern stopOrGo(semaphore: Semaphore) {
	Semaphore.signal(semaphore, signal);
	check(signal == Signal::STOP || signal == Signal::GO);
}",False,914,"[false, false, false, false, false]","[false, false, false, false, false]"
or,,TrackElements that are either connected or monitored by the same sensor.,"pattern relatedTrackElements(track1: TrackElement, track2: TrackElement){","pattern relatedTrackElements(track1: TrackElement, track2: TrackElement){
    TrackElement.monitoredBy(track1, sensor);
    TrackElement.monitoredBy(track2, sensor);
} or {
    TrackElement.connectsTo(track1,track2);
}","pattern relatedTrackElements(track1: TrackElement, track2: TrackElement){
	TrackElement.monitoredBy(track1, sensor);
	TrackElement.monitoredBy(track2, sensor);
} or {
	TrackElement.connectsTo(track1, track2);
}","pattern relatedTrackElements(track1: TrackElement, track2: TrackElement){
	TrackElement.monitoredBy(track1, sensor);
	TrackElement.monitoredBy(track2, sensor);
} or {
	TrackElement.connectsTo(track1, track2);
}","pattern relatedTrackElements(track1: TrackElement, track2: TrackElement){
	TrackElement.monitoredBy(track1, sensor);
	TrackElement.monitoredBy(track2, sensor);
} or {
	TrackElement.connectsTo(track1, track2);
}","pattern relatedTrackElements(track1: TrackElement, track2: TrackElement){
	TrackElement.monitoredBy(track1, sensor);
	TrackElement.monitoredBy(track2, sensor);
} or {
	TrackElement.connectsTo(track1, track2);
}","pattern relatedTrackElements(track1: TrackElement, track2: TrackElement) {
	TrackElement.monitoredBy(track1, sensor);
	TrackElement.monitoredBy(track2, sensor);
} or {
	TrackElement.connectsTo(track1, track2);
}",True,46011,"[true, true, true, true, true]","[true, true, true, true, true]"
neg,trainbenchmark-tool-viatra-patterns/src/hu/bme/mit/trainbenchmark/benchmark/viatra/SwitchMonitored.vql,Switches not monitored by a sensor.,pattern switchNotMonitored(sw : Switch){,"pattern switchNotMonitored(sw : Switch){
    neg find hasSensor(sw);
}
//auxiliary pattern
pattern hasSensor(sw : Switch){
    TrackElement.monitoredBy(sw, _);
}","pattern switchNotMonitored(sw : Switch) {
	Switch(sw);
	neg find monitoredSwitches(_, sw);
}

pattern monitoredSwitches(switch, sw : Switch) {
	Switch.monitoredBy(switch, sw);
}","pattern switchNotMonitored(sw : Switch) {
    neg find monitoredSwitches(sw);
}

pattern monitoredSwitches(sw : Switch) {
    Switch.monitoredBy(sw, _);
}","pattern switchNotMonitored(sw : Switch) {
    Switch(sw);
    neg find monitoredSwitches(sw, _);
}

pattern monitoredSwitches(sw : Switch, s : Sensor) {
    Switch.monitoredBy(sw, s);
}","pattern switchNotMonitored(sw : Switch) {
    Switch(sw);
    neg find monitoredSwitch(sw, _);
}

pattern monitoredSwitch(sw : Switch, sensor : Sensor) {
    Switch.monitoredBy(sw, sensor);
}","pattern switchNotMonitored(sw : Switch) {
	Switch(sw);
	neg find monitoredSwitch(sw);
}

pattern monitoredSwitch(sw : Switch) {
	Switch.monitoredBy(sw, _);
}",True,316,"[false, true, true, true, true]","[false, true, true, true, true]"
neg,trainbenchmark-tool-viatra-patterns/src/hu/bme/mit/trainbenchmark/benchmark/viatra/RouteSensor.vql,Retrieve sensors that monitor a switch. The switch position that target that switch is followed by a route. That sensor is not required by the route.,"pattern notRequiredRouteSensor(route : Route, sensor : Sensor, swP : SwitchPosition, sw : Switch){","pattern notRequiredRouteSensor(route : Route, sensor : Sensor, swP : SwitchPosition, sw : Switch){
    Route.follows(route, swP);
    SwitchPosition.target(swP, sw);
    TrackElement.monitoredBy(sw, sensor);
    neg find required(sensor, route);
}
//auxiliary pattern
pattern required(sensor : Sensor, route : Route){
    Route.requires(route, sensor);
}","pattern notRequiredRouteSensor(route : Route, sensor : Sensor, swP : SwitchPosition, sw : Switch) {
	Region.sensors(monitoredBy(sensor));
	SwitchPosition.target(swP, sw);
	Switch.positions(sw, swP);
	Route.follows(route, swP);
	neg find requiredSensorInRoute(route, sensor);
}","pattern notRequiredRouteSensor(route : Route, sensor : Sensor, swP : SwitchPosition, sw : Switch) {
    Region.elements(region, sw);
    Sensor.monitors(sensor, sw);
    SwitchPosition.target(swP, sw);
    Switch.positions(sw, swP);
    Route.follows(route, swP);
    Sensor.region(sensor, region);
    Sensor.region(sensor, region2);
    Route.requires(route, sensor2);
    check(sensor != sensor2);
}","pattern notRequiredRouteSensor(route : Route, sensor : Sensor, swP : SwitchPosition, sw : Switch) {
	Region.elements.monitoredBy(sensor);
	SwitchPosition.target(swP, sw);
	Switch.positions(sw, swP);
	Route.follows(route, swP);
	neg find requiredSensor(route, sensor);
}","pattern notRequiredRouteSensor(route : Route, sensor : Sensor, swP : SwitchPosition, sw : Switch) {
    Sensor.monitors(sensor, sw);
    SwitchPosition.target(swP, sw);
    Switch.positions(sw, swP);
    Route.follows(route, swP);
    Sensor != Route.requires(sensor, route);
}","pattern notRequiredRouteSensor(route : Route, sensor : Sensor, swP : SwitchPosition, sw : Switch) {
    Sensor.monitors(sensor, sw);
    SwitchPosition.target(swP, sw);
    Switch.positions(sw, swP);
    Route.follows(route, swP);
    Sensor.monitors(sensor, trackElement);
    Sensor != Route.requires(route, sensor);
}",False,2699,"[false, false, false, false, false]","[false, false, false, false, false]"
agg,,Total length of segments.,pattern totalLength(length: java Integer){,"pattern totalLength(length: java Integer){
    length == sum find segmentLength(_,#);
}
pattern segmentLength(segment: Segment, length: java Integer){
    Segment.length(segment, length);
}","pattern totalLength(length: java Integer){
	find segmentLength(_, length);
}

pattern segmentLength(segment: Segment, length: java Integer) {
	Segment.length(segment, length);
}","pattern totalLength(length: java Integer) {
	find segmentLength(_, segmentLength);
	check(length == sum(segmentLength));
}

pattern segmentLength(segment: Segment, length: java Integer) {
	Segment.length(segment, length);
}","pattern totalLength(length: java Integer) {
    Segment.length(segmentLength);
    check(segmentLength > 0);
    length == sum(segmentLength);
}","pattern totalLength(length: java Integer) {
	TrackElement.length(segmentLength);
	java Integer(segmentLength, length);
}","pattern totalLength(length: java Integer) {
	Segment.length(segmentLength);
	java Integer.sum(segmentLength, length);
}",False,612,"[true, false, false, false, false]","[false, false, false, false, false]"
agg,,Track elements monitored by at lest two sensors.,pattern monitoredBy2Sensors(track: TrackElement){,"pattern monitoredBy2Sensors(track: TrackElement){
    cnt == count find trackMonitoredBy(track, _);
    check(cnt >= 2);
}
pattern trackMonitoredBy(track: TrackElement, sensor: Sensor){
    TrackElement.monitoredBy(track, sensor);
}","pattern monitoredBy2Sensors(track: TrackElement) {
	TrackElement.monitoredBy(track, sensor1);
	TrackElement.monitoredBy(track, sensor2);
	sensor1 != sensor2;
	count find SensorForTrack(track, sensor1) == 1;
	count find SensorForTrack(track, sensor2) == 1;
}","pattern monitoredBy2Sensors(track: TrackElement) {
	TrackElement.monitoredBy(track, sensor1);
	TrackElement.monitoredBy(track, sensor2);
	sensor1 != sensor2;
	count find SensorForTrackElement(track, sensor1) == 1;
	count find SensorForTrackElement(track, sensor2) == 1;
}","pattern monitoredBy2Sensors(track: TrackElement) {
	TrackElement.monitoredBy(track, sensor1);
	TrackElement.monitoredBy(track, sensor2);
	sensor1 != sensor2;
}","pattern monitoredBy2Sensors(track: TrackElement) {
	TrackElement.monitoredBy(track, sensor1);
	TrackElement.monitoredBy(track, sensor2);
	sensor1 != sensor2;
}","pattern monitoredBy2Sensors(track: TrackElement) {
    TrackElement.monitoredBy(track, sensor1);
    TrackElement.monitoredBy(track, sensor2);
    sensor1 != sensor2;
}",True,4931,"[false, false, true, true, true]","[false, false, true, true, true]"
type,,RailwayElements that are either Switches or SwitchPositions.,pattern switchOrSwitchPositionRailwayElemements(raliway: RailwayElement){,"pattern switchOrSwitchPositionRailwayElemements(raliway: RailwayElement){
    Switch(raliway);
} or {
    SwitchPosition(raliway);
}","pattern switchOrSwitchPositionRailwayElemements(railway: RailwayElement) {
    Switch(railway);
} or {
    SwitchPosition(railway);
}","pattern switchOrSwitchPositionRailwayElements(railway: RailwayElement) {
    Switch(railway);
} or {
    SwitchPosition(railway);
}","pattern switchOrSwitchPositionRailwayElements(railway: RailwayElement) {
    RailwayElement(railway);
    Switch(railway) or SwitchPosition(railway);
}","pattern switchOrSwitchPositionRailwayElemements(railway: RailwayElement) {
	RailwayElement(railway);
	switchOrSwitchPosition(railway);
}

pattern switchOrSwitchPosition(elem: RailwayElement) {
	elem instanceof Switch;
} or {
	elem instanceof SwitchPosition;
}","pattern switchOrSwitchPositionRailwayElemements(railway: RailwayElement) {
	RailwayElement(railway);
	switchOrSwitchPosition(railway);
}

pattern switchOrSwitchPosition(elem: RailwayElement) {
	elem instanceof Switch;
} or {
	elem instanceof SwitchPosition;
}",True,3118,"[true, true, false, false, false]","[true, false, false, false, false]"
type,,Railway elements that are Switches.,pattern switchRailwayElements(railway: RailwayElement){,"pattern switchRailwayElements(railway: RailwayElement){
    Switch(railway);
}","pattern switchRailwayElements(railway: RailwayElement) {
    Switchrailway(railway);
}","pattern switchRailwayElements(switch : Switch) {
    RailwayElement(switch);
}","pattern switchRailwayElements(railway: RailwayElement){
    SwitchRailwayElement(railway);
}

pattern SwitchRailwayElement(switch: Switch) {
    RailwayElement(switch);
}","pattern switchRailwayElements(railway: RailwayElement) {
    SwitchRailwayElement(railway);
}

pattern SwitchRailwayElement(element: Switch) {
    RailwayElement(element);
}","pattern switchRailwayElements(switch : Switch){
	Switch(switch);
}",False,1902,"[false, false, false, false, false]","[false, false, false, false, false]"
normal,,Active routes with entry GO semaphore.,pattern goActiveRoute(route: Route){,"pattern goActiveRoute(route: Route){
    Route.active(route,true);
    Route.entry(route, semaphore);
    Semaphore.signal(semaphore, Signal::GO);    
}","pattern goActiveRoute(route: Route) {
	Route.active(route, true);
	Route.entry(route, semaphore);
	Semaphore.signal(semaphore, Signal::GO);
}","pattern goActiveRoute(route: Route) {
	Route.active(route, true);
	Route.entry(route, semaphore);
	Semaphore.signal(semaphore, Signal::GO);
}","pattern goActiveRoute(route: Route) {
	Route.active(route, true);
	Route.entry(route, semaphore);
	Semaphore.signal(semaphore, Signal::GO);
}","pattern goActiveRoute(route: Route) {
    Route.active(route, true);
    Route.entry(route, semaphore);
    Semaphore.signal(semaphore, Signal::GO);
}","pattern goActiveRoute(route: Route) {
    Route.active(route, true);
    Route.entry(route, semaphore);
    Semaphore.signal(semaphore, Signal::GO);
}",True,138,"[true, true, true, true, true]","[true, true, true, true, true]"
normal,trainbenchmark-tool-viatra-patterns/src/hu/bme/mit/trainbenchmark/benchmark/viatra/PosLength.vql,Retrieve all segments whose lengths are less or equal than zero.,pattern posLength(segment : Segment){,"pattern posLength(segment : Segment){
    Segment.length(segment, length);
    check(length <= 0);
}","pattern posLength(segment : Segment, length : EInt){
	Segment.length(segment, length);
	check(length <= 0);
}","pattern posLength(segment : Segment, length : EInt) {
	Segment.length(segment, length);
	check(length <= 0);
}","pattern posLength(segment : Segment, length : EInt){
	Segment.length(segment, length);
	check(length <= 0);
}","pattern posLength(segment : Segment, length : EInt){
	Segment.length(segment, length);
	check(length <= 0);
}","pattern posLength(segment : Segment, length : EInt){
	Segment.length(segment, length);
	check(length <= 0);
}",False,2576,"[true, true, true, true, true]","[false, false, false, false, false]"
normal,,SwitchPositions where the target Switch's current position is different from the SwitchPosition's position.,pattern misalignedSwitchPosition(swP : SwitchPosition){,"pattern misalignedSwitchPosition(swP : SwitchPosition){
    SwitchPosition.target(swP, sw);
    SwitchPosition.position(swP, swpPosition);
    Switch.currentPosition(sw, swCurrentPosition);
    swpPosition != swCurrentPosition;
}","pattern misalignedSwitchPosition(swP : SwitchPosition) {
	SwitchPosition.position(spPos);
	SwitchPosition.target.targetSwitch.currentPosition(tarPos);
	check(spPos != tarPos);
}","pattern misalignedSwitchPosition(swP : SwitchPosition) {
	SwitchPosition.position(spPos);
	SwitchPosition.target.switch(Switch.currentPosition(swCurrPos));
	check(spPos != swCurrPos);
}","pattern misalignedSwitchPosition(swP : SwitchPosition) {
	SwitchPosition.position(swP, pos);
	SwitchPosition.target(swP, targetSwitch);
	Switch.currentPosition(targetSwitch, currentPosition);
	check(Position.DIVERGING != pos || pos != currentPosition);
}","pattern misalignedSwitchPosition(swP : SwitchPosition) {
	SwitchPosition.position(spPos);
	Switch.target.currentPosition(tarPos);
	check(spPos != tarPos);
}","pattern misalignedSwitchPosition(swP : SwitchPosition){
	SwitchPosition.position(spPos);
	Switch(currentPosition != spPos)(target == swP);
}",False,773,"[false, false, false, false, false]","[false, false, false, false, false]"
mix,,"Regions where the sum of segments lengths is at least 50, or regions with at least 10 sensors.",pattern bigRegion(region: Region){,"pattern bigRegion(region: Region){
    length == sum find trackLengthInRegion(region, _,#);
    check(length >= 50);
} or {
    cnt == count find sensorInRegion(region, _);
    check(cnt >= 10);
}
pattern trackLengthInRegion(region: Region, track: Segment, length: EInt){
    Region.elements(region,track);
    Segment.length(track,length);
}
pattern sensorInRegion(region:Region, sensor: Sensor){
    Region.sensors(region,sensor);
}","pattern bigRegion(region: Region) {
	Region(region);
	check(
		count find segmentInRegion(region, _segment) > 0
		&& sum find segmentLength(_segment, _length) >= 50
		|| count find sensorInRegion(region, _) >= 10
	);
}

pattern segmentInRegion(region: Region, segment: Segment) {
	Region.elements(region, segment);
}

pattern segmentLength(segment: Segment, length: EInt) {
	Segment.length(segment, length);
}

pattern sensorInRegion(region: Region, sensor: Sensor) {
	Region.sensors(region, sensor);
}","pattern bigRegion(region: Region) {
	Region(region);
	check(count find segmentInRegion(region, _) >= 50 or count find sensorInRegion(region, _) >= 10);
}

pattern segmentInRegion(region: Region, segment: Segment) {
	Region.elements(region, element);
	TrackElement.connectsTo(element, segment);
	Segment.length(segment, _);
}

pattern sensorInRegion(region: Region, sensor: Sensor) {
	Region.sensors(region, sensor);
}","pattern bigRegion(region: Region) {
	Region(region);
	neg find regionsWithAtLeast10Sensors(region);
	neg find regionsWithSumOfSegmentLengths(region);
}

pattern regionsWithAtLeast10Sensors(region: Region) {
	Region(region);
	count find sensorsInRegion(region, _);
	check(count >= 10);
}

pattern regionsWithSumOfSegmentLengths(region: Region) {
	Region(region);
	sum find segmentLengthsInRegion(region, _);
	check(sum >= 50);
}

pattern sensorsInRegion(region: Region, sensor: Sensor) {
	Region.sensors(region, sensor);
}

pattern segmentLengthsInRegion(region: Region, length: EInt) {
	Region.elements(region, element);
	TrackElement.length(element, length);
}","pattern bigRegion(region: Region) {
	Region(region);
	check(
		sumOfSegmentLengths(region) >= 50
		||
		countSensors(region) >= 10
	);
}

helper pattern sumOfSegmentLengths(region: Region, length: Integer) {
	Region.elements(region, segment);
	Segment.length(segment, length);
}

helper pattern countSensors(region: Region, count: Integer) {
	Region.sensors(region, sensor);
	count == countFind(sensor);
}","pattern bigRegion(region: Region){
	Region(region);
	check(
		count find segmentInRegion(region, _) > 0 && sum find segmentLengthInRegion(region, _) >= 50
		||
		count find sensorInRegion(region, _) >= 10
	);
}

pattern segmentInRegion(region: Region, segment: Segment){
	Region.elements.region(segment);
}

pattern segmentLengthInRegion(region: Region, length: Integer){
	Segment.length(segment, length);
	Region.elements.region(segment);
}

pattern sensorInRegion(region: Region, sensor: Sensor){
	Region.sensors.region(sensor);
}",False,576,"[false, false, false, false, false]","[false, false, false, false, false]"
mix,,Segments that are at least 7 units long or are switches.,pattern sevenSegmentOrSwitch(track: TrackElement){,"pattern sevenSegmentOrSwitch(track: TrackElement){
    Switch(track);
} or {
    Segment.length(track, length);
    check(length >= 7);
}","pattern sevenSegmentOrSwitch(track: TrackElement) {
	TrackElement(track);
	Segment(track, length >= 7);
} or {
	TrackElement(track);
	Switch(track);
}","pattern sevenSegmentOrSwitch(track: TrackElement) {
	TrackElement.length(track, length);
	check(length >= 7 or track instanceof Switch);
}","pattern sevenSegmentOrSwitch(track: TrackElement){
	TrackElement.length(track, length);
	check(length >= 7 or track instanceof Switch);
}","pattern sevenSegmentOrSwitch(track: TrackElement){
	TrackElement.length(track, length);
	check(length >= 7 or track instanceof Switch);
}","pattern sevenSegmentOrSwitch(track: TrackElement){
	TrackElement.length(track, length);
	check(length >= 7 or track instanceof Switch);
}",False,3160,"[false, false, false, false, false]","[false, false, false, false, false]"
mix,,Active route whose entry is a GO semaphore but not monitored by any sensor.,pattern dangerousRoute(route: Route){,"pattern dangerousRoute(route: Route){
        find activeRouteWithGO(route);
        neg find routeMonitroedBy(route,_);
}
pattern routeMonitroedBy(route: Route, sensor: Sensor){
    Route.requires(route, sensor);
}
pattern activeRouteWithGO(route: Route){
    Route.active(route, true);
    Route.entry(route, entry);
    Semaphore.signal(entry, ::GO);
}","pattern dangerousRoute(route: Route){
	Route.active(route, true);
	Route.entry(route, entrySemaphore);
	Semaphore.signal(entrySemaphore, Signal::GO);
	neg find monitoredSensor(route, _sensor);
}","pattern dangerousRoute(route: Route) {
    Route.active(route, true);
    Route.entry(route, entrySemaphore);
    Semaphore.signal(entrySemaphore, Signal::GO);
    neg find monitoredSensor(route, _sensor);
}","pattern dangerousRoute(route: Route) {
    Route.active(route, true);
    Route.entry(route, entrySemaphore);
    Semaphore.signal(entrySemaphore, Signal::GO);
    neg find monitoredBySensor(route, _);
}","pattern dangerousRoute(route: Route) {
    Route.active(route, true);
    Route.entry(route, entrySemaphore);
    Semaphore.signal(entrySemaphore, Signal::GO);
    neg find monitoredRouteSensor(route, _);
}
pattern monitoredRouteSensor(route: Route, sensor: Sensor) {
    Route.requires(route, sensor);
}","pattern dangerousRoute(route: Route) {
	Route.active(route, true);
	Route.entry(route, entrySemaphore);
	Semaphore.signal(entrySemaphore, Signal::GO);
	neg find monitoredBySensor(route, _);
}",True,49,"[false, false, false, true, false]","[false, false, false, true, false]"
neg,https://github.com/ftsrg/trainbenchmark/blob/master/trainbenchmark-tool-viatra-patterns/src/hu/bme/mit/trainbenchmark/benchmark/viatra/SemaphoreNeighbor.vql,"Two different routes where the exit semaphore of a route is not the entry semaphore of the other. Each route requires a sensor, and the sensors monitor connected tracks.","pattern semaphoreNeighbor(semaphore: Semaphore, route1: Route, route2: Route, sensor1: Sensor, sensor2: Sensor, te1: TrackElement, te2: TrackElement){","pattern semaphoreNeighbor(semaphore: Semaphore, route1: Route, route2: Route, sensor1: Sensor, sensor2: Sensor, te1: TrackElement, te2: TrackElement){
       Route.exit(route1, semaphore);
	Route.requires(route1, sensor1);
	TrackElement.monitoredBy(te1, sensor1);
	TrackElement.connectsTo(te1, te2);
	TrackElement.monitoredBy(te2, sensor2);
	Route.requires(route2, sensor2);
	
	neg find entrySemaphore(route2, semaphore);

	route1 != route2;
}

pattern entrySemaphore(route: Route, semaphore: Semaphore)
{
	Route.entry(route, semaphore);
}","pattern semaphoreNeighbor(semaphore: Semaphore, route1: Route, route2: Route, sensor1: Sensor, sensor2: Sensor, te1: TrackElement, te2: TrackElement) {
    Route.requires(route1, sensor1);
    Route.requires(route2, sensor2);
    Sensor.monitors(sensor1, te1);
    Sensor.monitors(sensor2, te2);
    Route.exit(route1, semaphore);
    Route.entry(route2, semaphore);
    check(route1 != route2);
}","pattern semaphoreNeighbor(semaphore: Semaphore, route1: Route, route2: Route, sensor1: Sensor, sensor2: Sensor, te1: TrackElement, te2: TrackElement) {
    Route.requires(route1, sensor1);
    Sensor.monitors(sensor1, te1);
    TrackElement.connectsTo(te1, te2);
    Route.exit(route1, semaphore);
    Route.entry(route2, semaphore);
    Route.requires(route2, sensor2);
    Sensor.monitors(sensor2, te2);
    Route != route2;
}","pattern semaphoreNeighbor(semaphore: Semaphore, route1: Route, route2: Route, sensor1: Sensor, sensor2: Sensor, te1: TrackElement, te2: TrackElement) {
    Route.requires(route1, sensor1);
    Sensor.monitors(sensor1, te1);
    Route.exit(route1, semaphore);
    Route.requires(route2, sensor2);
    Sensor.monitors(sensor2, te2);
    Route.entry(route2, semaphore);
    Route != route2;
    Semaphore.signal(semaphore, _);
    Semaphore != semaphore;
}","pattern semaphoreNeighbor(semaphore: Semaphore, route1: Route, route2: Route, sensor1: Sensor, sensor2: Sensor, te1: TrackElement, te2: TrackElement) {
    Route.requires(route1, sensor1);
    Route.requires(route2, sensor2);
    Sensor.monitors(sensor1, te1);
    Sensor.monitors(sensor2, te2);
    Route.exit(route1, semaphore);
    Route.entry(route2, semaphore);
    check(route1 != route2);
}","pattern semaphoreNeighbor(semaphore: Semaphore, route1: Route, route2: Route, sensor1: Sensor, sensor2: Sensor, te1: TrackElement, te2: TrackElement) {
    Route.exit(route1, semaphore);
    Route.entry(route2, semaphore);
    Route.requires(route1, sensor1);
    Route.requires(route2, sensor2);
    Sensor.monitors(sensor1, te1);
    Sensor.monitors(sensor2, te2);
    TrackElement.connectsTo(te1, te2);
    different(route1, route2);
}",False,6,"[false, false, false, false, false]","[false, false, false, false, false]"
