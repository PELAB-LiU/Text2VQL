# Do you want descriptors for auxilary patterns?

Given this metamodel

class Pseudostate extends Vertex {
}
class Vertex {
    ref Transition[0, *] incomingTransitions;
    ref Transition[0, *] outgoingTransitions;
}
class Region {
    ref Vertex[0, *] vertices;
}
class Transition {
    ref Vertex[1, 1] target;
    ref Vertex[0, 1] source;
}
class Statechart extends CompositeElement {
}
class Entry extends Pseudostate {
}
class Synchronization extends Pseudostate {
}
class State extends RegularState, CompositeElement {
}
class RegularState extends Vertex {
}
class CompositeElement {
    ref Region[0, *] regions;
...
}
class FinalState extends RegularState {
}

and the following Viatra Query examples

Example 1:
Description: "Entries that do not have outgoing transitions. Auxilary pattern is hasOutgoingTransition."
Query:
pattern entryWithoutOutgoingTransitions(e : Entry) {
    Entry(e);
    neg find hasOutgoingTransition(e);
}

//auxiliary pattern
pattern hasOutgoingTransition(vertex : Vertex) {
    Vertex.outgoingTransitions(vertex,_);
}

Example 2:
Description: "Regions that have no states. Auxilary pattern is stateInRegion."
Query:
pattern noStateInRegion(region: Region) {
    neg find StateInRegion(region, _);
}

//auxiliary pattern
pattern stateInRegion(region: Region, state: State) {
    Region.vertices(region, state);
}

Example 3:
Description: "Entries that have multiple outgoing transitions"
Query:
pattern entryWithMultipleOutgoingTransitions(entry : Entry) {
    Entry.outgoingTransitions(entry, transition1);
    Entry.outgoingTransitions(entry, transition2);
    transition1!=transition2;
}

Example 4:
Description: "All entries with their regions"
Query:
pattern entryInRegion(region : Region, entry : Entry) {
    Region.vertices(region, entry);
}

Based on the followign mentamodel, generate 5 Viatra Queries of increasing complexity and ther descriptions that containing neg statement.
Provide description for the auxilary pattern.

class Database extends ModelElement {
    attr EString[0, 1] name;
    attr EString[0, 1] url;
    ref Schema[0, *] ownedSchemas;
}
class Schema extends ModelElement {
    attr EString[0, 1] name;
    ref Table[0, *] ownedTables;
    ref Database[1, 1] owner;
}
class Table extends ModelElement {
    attr EString[0, 1] name;
    ref Column[0, *] ownedColumns;
    ref ForeignKey[0, *] ownedForeignKeys;
    ref Schema[1, 1] owner;
}
class ForeignKey extends ModelElement {
    attr EString[0, 1] name;
    ref Table[1, 1] foreignTable;
    ref Table[1, 1] sourceTable;
}
class Column extends ModelElement {
    attr EString[0, 1] name;
    attr Type[0, 1] type;
    attr EBoolean[0, 1] isPrimaryKey;
    attr EBoolean[0, 1] isUnique;
    ref Table[1, 1] owner;
}
enum Type {
    NUMERIC;
    VARCHAR;
    DATE;
    TIME;
    FLOAT;
    CHAR;
}
class ModelElement {
    attr EString[0, 1] comment;
}